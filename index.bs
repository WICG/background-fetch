<pre class="metadata">
Title: Background Fetch
Shortname: background-fetch
Level: 1
Status: ED
Group: wicg
URL: https://jakearchibald.github.io/background-fetch
Editor: Jake Archibald, Google, jakearchibald@google.com
Editor: Peter Beverloo, Google, beverloo@google.com
Abstract: An API to handle large uploads/downloads in the background with user visibility.
Markup Shorthands: css no, markdown yes
Indent: 2
</pre>

<pre class="link-defaults">
spec:infra; type:dfn; text:list
</pre>

# Introduction # {#intro}

A [=service worker=] is capable of fetching and caching assets, the size of which is restricted only by [origin storage](https://storage.spec.whatwg.org/#usage-and-quota). However, if the user navigates away from the site or closes the browser, the service worker is [[service-workers#service-worker-lifetime|likely to be killed]]. This can happen even if there's a pending promise passed to {{ExtendableEvent/waitUntil()}}; if it hasn't resolved within a few minutes the browser may consider it an abuse of [=service worker=] and kill the process.

This makes it difficult to download and cache large assets such as podcasts and movies, and upload video and images. Even if the [=service worker=] isn't killed, having to keep the [=service worker=] in memory during this potentially long operation is wasteful.

This specification aims to:

* Allow [=/fetches=] to continue even if the user closes all windows & worker to the origin.
* Allow a single job to involve many requests, as defined by the app.
* Allow the browser/OS to show UI to indicate the progress of the [=/fetch=], and allow the user to pause/abort.
* Allow the browser/OS to deal with poor connectivity by pausing/resuming the download/upload (may be tricky with uploads, as ranged uploads aren't standardized)
* Allow the app to react to success/failure of the background fetch group, perhaps by caching the results.
* Allow access to background-fetched resources as they [=/fetch=].
* Allow the app to display progress information about a background fetch.
* Allow the app to suggest which connection types the [=/fetch=] should be restricted to.

# Infrastructure # {#infrastructure}

## Parallel queues ## {#parallel-queues}

The HTML spec allows us to run steps [=in parallel=], but doesn't provide a way to create queues of parallel steps. This is an attempt to solve that problem generally. See [whatwg/html/issues/1843](https://github.com/whatwg/html/issues/1843) for discussion.

<div algorithm>
  To <dfn export lt="create a parallel queue|creating a parallel queue">create a parallel queue</dfn>, run the following steps:

  1. Let |stepsQueue| be a new [=queue=].
  1. Run the following steps [=in parallel=]:
    1. While true:
      1. Let |steps| be the result of [=dequeueing=] |stepsQueue|.
      1. If |steps| is not nothing, run |steps| and catch any error.
  1. Return |stepsQueue|.
</div>

<div class="example">
  Imagine each origin has a [=list=], and |nameList| is one of those. If we wanted to add |name| to |nameList|, but reject if |nameList| already [=list/contains=] |nameList|, the following would be racy:

  1. Let |p| be [=a new promise=].
  1. Run the following steps [=in parallel=]:
    1. If |nameList| [=list/contains=] |name|, [=reject=] |p| with a {{TypeError}} and abort these steps.
    1. Do some potentially lengthy work.
    1. [=list/Append=] |name| to |nameList|.
    1. [=Resolve=] |p| with undefined.
  1. Return |p|.

  Two invocations of the above could run simultaneously, meaning |name| isn't in |nameList| during step 2.1, but it *is there* before step 2.3, meaning |name| ends up in |nameList| twice.

  Parallel queues solve this. |nameListQueue| would be the result of [=creating a parallel queue=] for the same origin as |nameList|, then:

  1. Let |p| be [=a new promise=].
  1. <strong>[=queue/Enqueue=] the following steps to |nameListQueue|:</strong>
    1. If |nameList| [=list/contains=] |name|, [=reject=] |p| with a {{TypeError}} and abort these steps.
    1. Do some potentially lengthy work.
    1. [=list/Append=] |name| to |nameList|.
    1. [=Resolve=] |p| with undefined.
  1. Return |p|.

  The steps would now queue, and the race is avoided.
</div>

## Extensions to service worker registration ## {#service-worker-registration-concept-extensions}

A [=service worker registration=] has an associated <dfn for="service worker registration">list of active background fetches</dfn>, a [=list=], where each item is a [=/background fetch=].

## Background fetch ## {#background-fetch-concept}

A <dfn>background fetch</dfn> consists of:

<div dfn-for="background fetch">
  * An <dfn>id</dfn>, which is a DOMString.
  * TODO: add additional state
</div>

# API # {#api}

## Extensions to {{ServiceWorkerRegistration}} ## {#extensions-to-service-worker-registration}

<pre class="idl"><xmp>
  partial interface ServiceWorkerRegistration {
    readonly attribute BackgroundFetchManager backgroundFetch;
  };
</xmp></pre>

Each {{ServiceWorkerRegistration}} instance has a unique instance of {{BackgroundFetchManager}}, allocated when the {{ServiceWorkerRegistration}} object is created.

The <dfn attribute for="ServiceWorkerRegistration">backgroundFetch</dfn> attribute must return the {{BackgroundFetchManager}} object that is associated with the [=context object=].

## {{BackgroundFetchManager}} ## {#background-fetch-manager}

<pre class="idl"><xmp>
  [Exposed=(Window,Worker)]
  interface BackgroundFetchManager {
    Promise<BackgroundFetchRegistration> fetch(DOMString id, (RequestInfo or sequence<RequestInfo>) requests, optional BackgroundFetchOptions options);
    Promise<BackgroundFetchRegistration?> get(DOMString id);
    Promise<FrozenArray<DOMString>> getIds();
    // TODO: in future this should become an async iterator for BackgroundFetchRegistration objects
  };

  dictionary BackgroundFetchOptions {
    sequence<IconDefinition> icons = [];
    DOMString title = "";
    long totalDownloadSize = 0;
  };

  // This is taken from https://w3c.github.io/manifest/#icons-member.
  // This definition should probably be moved somewhere more general.
  dictionary IconDefinition {
    DOMString src;
    DOMString sizes = "";
    DOMString type = "";
  };
</xmp></pre>

<div dfn-for="BackgroundFetchManager">
  <div algorithm>
    The <dfn method>fetch(|id|, |requests|, |options|)</dfn> method, when invoked, must return [=a new promise=] |promise| and run the following steps [=in parallel=]:

      1. Let |registration| be the [=context object=]'s associated [=/service worker registration=].
      1. TODO.
  </div>

  <div algorithm>
    The <dfn method>get(|id|)</dfn> method, when invoked, must return [=a new promise=] |promise| and run the following steps [=in parallel=]:

      1. TODO
  </div>

  <div algorithm>
    The <dfn method>getIds()</dfn> method, when invoked, must return [=a new promise=] |promise| and run the following steps [=in parallel=]:

      1. TODO
  </div>
</div>

## {{BackgroundFetchRegistration}} ## {#background-fetch-registration}

<pre class="idl"><xmp>
  [Exposed=(Window,Worker)]
  interface BackgroundFetchRegistration : EventTarget {
    readonly attribute DOMString id;
    readonly attribute FrozenArray<IconDefinition> icons;
    readonly attribute unsigned long long uploadTotal;
    readonly attribute unsigned long long uploaded;
    readonly attribute unsigned long long downloadTotal;
    readonly attribute unsigned long long downloaded;
    readonly attribute DOMString title;
    readonly attribute FrozenArray<BackgroundFetchActiveFetch> activeFetches;

    Promise<boolean> abort();
  };

  [Exposed=(Window,Worker)]
  interface BackgroundFetchFetch {
    readonly attribute Request request;
  };

  [Exposed=(Window,Worker)]
  interface BackgroundFetchActiveFetch : BackgroundFetchFetch {
    readonly attribute Promise<Response> responseReady;
    // TODO: this will include fetch controller/observer objects
  };
</xmp></pre>

<div dfn-for="BackgroundFetchRegistration">
  A {{BackgroundFetchRegistration}} instance has an associated <dfn>background fetch</dfn>, a [=/background fetch=].

  The <dfn attribute>id</dfn> attribute's getter must return the [=context object=]'s [=background fetch/id=].

  The <dfn attribute>icons</dfn> attribute's getter must return the [=context object=]'s TODO.

  The <dfn attribute>uploadTotal</dfn> attribute's getter must return the [=context object=]'s TODO.

  The <dfn attribute>uploaded</dfn> attribute's getter must return the [=context object=]'s TODO.

  The <dfn attribute>downloadTotal</dfn> attribute's getter must return the [=context object=]'s TODO.

  The <dfn attribute>downloaded</dfn> attribute's getter must return the [=context object=]'s TODO.

  The <dfn attribute>title</dfn> attribute's getter must return the [=context object=]'s TODO.

  The <dfn attribute>activeFetches</dfn> attribute's getter must return the [=context object=]'s TODO.

  <div algorithm>
    The <dfn method>abort()</dfn> method, when invoked, must return [=a new promise=] |promise| and run the following steps [=in parallel=]:

      1. TODO
  </div>
</div>

## Events ## {#events}

<pre class="idl"><xmp>
  partial interface ServiceWorkerGlobalScope {
    attribute EventHandler onbackgroundfetched;
    attribute EventHandler onbackgroundfetchfail;
    attribute EventHandler onbackgroundfetchabort;
    attribute EventHandler onbackgroundfetchclick;
  };
</xmp></pre>

The following is the <a>event handler</a> (and its corresponding <a>event handler event type</a>) that must be supported, as <a>event handler IDL attributes</a>, by all objects implementing {{ServiceWorker}} interface:

<table class="data">
  <thead>
    <tr>
      <th>[=event handler event type=]</th>
      <th>[=event handler=]</th>
      <th>Interface</th>
    </tr>
  </thead>
  <tbody dfn-for="ServiceWorkerGlobalScope" dfn-type="event">
    <tr>
      <td><dfn>backgroundfetched</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetched}}</td>
      <td>{{BackgroundFetchedEvent}}</td>
    </tr>
    <tr>
      <td><dfn>backgroundfetchfail</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetchfail}}</td>
      <td>{{BackgroundFetchFailEvent}}</td>
    </tr>
    <tr>
      <td><dfn>backgroundfetchabort</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetchabort}}</td>
      <td>{{BackgroundFetchEvent}}</td>
    </tr>
    <tr>
      <td><dfn>backgroundfetchclick</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetchclick}}</td>
      <td>{{BackgroundFetchClickEvent}}</td>
    </tr>
  </tbody>
</table>

### {{BackgroundFetchEvent}} ### {#background-fetch-event}

<pre class="idl"><xmp>
  [Constructor(DOMString type, BackgroundFetchEventInit init), Exposed=ServiceWorker]
  interface BackgroundFetchEvent : ExtendableEvent {
    readonly attribute DOMString id;
  };

  dictionary BackgroundFetchEventInit : ExtendableEventInit {
    required DOMString id;
  };
</xmp></pre>

<div dfn-for="BackgroundFetchEvent">
  A {{BackgroundFetchEvent}} has an associated <dfn>id</dfn>, a DOMString.

  The <dfn attribute>id</dfn> attribute must return the [=BackgroundFetchEvent/id=].

  TODO
</div>

<div algorithm>
  The <dfn constructor for="BackgroundFetchEvent">BackgroundFetchEvent(|type|, |init|)</dfn> constructor, when invoked, must run these steps:

  1. TODO
</div>

### {{BackgroundFetchedEvent}} ### {#background-fetch-end-event}

<pre class="idl"><xmp>
  [Constructor(DOMString type, BackgroundFetchedEventInit init), Exposed=ServiceWorker]
  interface BackgroundFetchedEvent : BackgroundFetchEvent {
    readonly attribute FrozenArray<BackgroundFetchSettledFetch> fetches;

    Promise<void> updateUI(DOMString title);
  };

  dictionary BackgroundFetchedEventInit : BackgroundFetchEventInit {
    required sequence<BackgroundFetchSettledFetch> fetches;
  };

  [Exposed=ServiceWorker]
  interface BackgroundFetchSettledFetch : BackgroundFetchFetch {
    readonly attribute Response? response;
  };
</xmp></pre>

<div dfn-for="BackgroundFetchedEvent">
  The <dfn attribute>completeFetches</dfn> attribute must return TODO.

  <div algorithm>
    The <dfn method>updateUI(|title|)</dfn> method, when invoked, must return [=a new promise=] |promise| and run the following steps [=in parallel=]:

      1. TODO
  </div>
</div>

<div algorithm>
  The <dfn constructor for="BackgroundFetchedEvent">BackgroundFetchedEvent(|type|, |init|)</dfn> constructor, when invoked, must run these steps:

  1. TODO
</div>

### {{BackgroundFetchFailEvent}} ### {#background-fetch-fail-event}

<pre class="idl"><xmp>
  [Constructor(DOMString type, BackgroundFetchedEventInit init), Exposed=ServiceWorker]
  interface BackgroundFetchFailEvent : BackgroundFetchedEvent {
    readonly attribute FrozenArray<BackgroundFetchSettledFetch> fetches;
  };

  dictionary BackgroundFetchFailEventInit : BackgroundFetchedEventInit {
    required sequence<BackgroundFetchSettledFetch> fetches;
  };
</xmp></pre>

### {{BackgroundFetchClickEvent}} ### {#background-fetch-click-event}

<pre class="idl"><xmp>
  [Constructor(DOMString type, BackgroundFetchedEventInit init), Exposed=ServiceWorker]
  interface BackgroundFetchClickEvent : BackgroundFetchEvent {
    readonly attribute BackgroundFetchState state;
  };

  dictionary BackgroundFetchClickEventInit : BackgroundFetchEventInit {
    required BackgroundFetchState state;
  };

  enum BackgroundFetchState { "pending", "succeeded", "failed" };
</xmp></pre>
