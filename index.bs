<pre class="metadata">
Title: Background Fetch
Shortname: background-fetch
Level: 1
Status: ED
Group: wicg
URL: https://jakearchibald.github.io/background-fetch
Editor: Jake Archibald, Google, jakearchibald@google.com
Editor: Peter Beverloo, Google, beverloo@google.com
Abstract: An API to handle large uploads/downloads in the background with user visibility.
Markup Shorthands: css no, markdown yes
Indent: 2
</pre>

<pre class="link-defaults">
spec:infra; type:dfn; text:list
spec:fetch; type:interface; text:ReadableStream
</pre>

# Introduction # {#intro}

A [=service worker=] is capable of fetching and caching assets, the size of which is restricted only by [origin storage](https://storage.spec.whatwg.org/#usage-and-quota). However, if the user navigates away from the site or closes the browser, the service worker is [[service-workers#service-worker-lifetime|likely to be killed]]. This can happen even if there's a pending promise passed to {{ExtendableEvent/waitUntil()}}; if it hasn't resolved within a few minutes the browser may consider it an abuse of [=service worker=] and kill the process.

This makes it difficult to download and cache large assets such as podcasts and movies, and upload video and images. Even if the [=service worker=] isn't killed, having to keep the [=service worker=] in memory during this potentially long operation is wasteful.

This specification aims to:

* Allow [=/fetches=] to continue even if the user closes all windows & worker to the origin.
* Allow a single job to involve many requests, as defined by the app.
* Allow the browser/OS to show UI to indicate the progress of the [=/fetch=], and allow the user to pause/abort.
* Allow the browser/OS to deal with poor connectivity by pausing/resuming the download/upload (may be tricky with uploads, as ranged uploads aren't standardized)
* Allow the app to react to success/failure of the background fetch group, perhaps by caching the results.
* Allow access to background-fetched resources as they [=/fetch=].
* Allow the app to display progress information about a background fetch.
* Allow the app to suggest which connection types the [=/fetch=] should be restricted to.

# Infrastructure # {#infrastructure}

## Parallel queues ## {#parallel-queues}

The HTML spec allows us to run steps [=in parallel=], but doesn't provide a way to create queues of parallel steps. This is an attempt to solve that problem generally. See [whatwg/html/issues/1843](https://github.com/whatwg/html/issues/1843) for discussion.

<div algorithm>
  To <dfn export lt="start a parallel queue|starting a parallel queue">start a parallel queue</dfn>, run the following steps:

  1. Let |stepsQueue| be a new [=queue=].
  1. Run the following steps [=in parallel=]:
    1. While true:
      1. Let |steps| be the result of [=dequeueing=] |stepsQueue|.
      1. If |steps| is not nothing, run |steps| and catch any error.
  1. Return |stepsQueue|.
</div>

<div class="example">
  Imagine each origin has a [=list=], and |nameList| is one of those. If we wanted to add |name| to |nameList|, but reject if |nameList| already [=list/contains=] |nameList|, the following would be racy:

  1. Let |p| be [=a new promise=].
  1. Run the following steps [=in parallel=]:
    1. If |nameList| [=list/contains=] |name|, [=reject=] |p| with a {{TypeError}} and abort these steps.
    1. Do some potentially lengthy work.
    1. [=list/Append=] |name| to |nameList|.
    1. [=Resolve=] |p| with undefined.
  1. Return |p|.

  Two invocations of the above could run simultaneously, meaning |name| isn't in |nameList| during step 2.1, but it *is there* before step 2.3, meaning |name| ends up in |nameList| twice.

  Parallel queues solve this. |nameListQueue| would be the result of [=starting a parallel queue=] for the same origin as |nameList|, then:

  1. Let |p| be [=a new promise=].
  1. <strong>[=queue/Enqueue=] the following steps to |nameListQueue|:</strong>
    1. If |nameList| [=list/contains=] |name|, [=reject=] |p| with a {{TypeError}} and abort these steps.
    1. Do some potentially lengthy work.
    1. [=list/Append=] |name| to |nameList|.
    1. [=Resolve=] |p| with undefined.
  1. Return |p|.

  The steps would now queue, and the race is avoided.
</div>

## Extensions to service worker registration ## {#service-worker-registration-concept-extensions}

A [=service worker registration=] additionally has:

<div dfn-for="service worker registration">
  * An associated <dfn>active background fetches</dfn> (a [=map=]), where each key is a DOMString, and each item is a [=/background fetch=]. It is initially an empty [=map=].
  * An associated <dfn>active background fetches edit queue</dfn> (a [=queue=]), initially the result of [=starting a parallel queue=].
</div>

## Background fetch ## {#background-fetch-concept}

A <dfn>background fetch</dfn> consists of:

<div dfn-for="background fetch">
  * An <dfn>id</dfn> (a DOMString).
  * <dfn>Records</dfn> (a [=list=] of [=/background fetch records=]).
  * A <dfn>title</dfn> (a DOMString).
  * A <dfn>download total</dfn> (a number).
  * An <dfn>upload total</dfn> (a number).
  * <dfn>Icons</dfn> (a [=list=] of {{IconDefinition}}s).
</div>

## Background fetch record ## {#background-fetch-record-concept}

A <dfn>background fetch record</dfn> consists of:

<div dfn-for="background fetch record">
  * A <dfn>request</dfn> (a [=/request=]).
  * A <dfn>response</dfn> (a [=/response=]), initially null.
  * A <dfn>response body</dfn> (a byte sequence), initially null.
</div>

# API # {#api}

## Extensions to {{ServiceWorkerRegistration}} ## {#extensions-to-service-worker-registration}

<pre class="idl"><xmp>
  partial interface ServiceWorkerRegistration {
    readonly attribute BackgroundFetchManager backgroundFetch;
  };
</xmp></pre>

Each {{ServiceWorkerRegistration}} instance has a unique instance of {{BackgroundFetchManager}}, allocated when the {{ServiceWorkerRegistration}} object is created.

The <dfn attribute for="ServiceWorkerRegistration">backgroundFetch</dfn> attribute must return the {{BackgroundFetchManager}} object that is associated with the [=context object=].

## {{BackgroundFetchManager}} ## {#background-fetch-manager}

<pre class="idl"><xmp>
  [Exposed=(Window,Worker)]
  interface BackgroundFetchManager {
    Promise<BackgroundFetchRegistration> fetch(DOMString id, (RequestInfo or sequence<RequestInfo>) requests, optional BackgroundFetchOptions options);
    Promise<BackgroundFetchRegistration?> get(DOMString id);
    Promise<FrozenArray<DOMString>> getIds();
    // TODO: in future this should become an async iterator for BackgroundFetchRegistration objects
  };

  dictionary BackgroundFetchOptions {
    sequence<IconDefinition> icons = [];
    DOMString title = "";
    unsigned long long downloadTotal = 0;
  };

  // This is taken from https://w3c.github.io/manifest/#icons-member.
  // This definition should probably be moved somewhere more general.
  dictionary IconDefinition {
    DOMString src;
    DOMString sizes = "";
    DOMString type = "";
  };
</xmp></pre>

<div dfn-for="BackgroundFetchManager">

  A {{BackgroundFetchManager}} has a <dfn>BackgroundFetchRegistration instances</dfn> (a [=map=]), where the keys are [=/background fetch|background fetches=] and the values are {{BackgroundFetchRegistration}} objects. It is initially empty.

  <div algorithm>
    The <dfn method>fetch(|id|, |requests|, |options|)</dfn> method, when invoked, run the following steps:

    1. Let |registration| be the [=context object=]'s associated [=/service worker registration=].
    1. Let |records| be a new [=list=].
    1. Let |uploadTotal| be 0.
    1. If |requests| is a {{RequestInfo}}, set |requests| to « |requests| ».
    1. If |requests| is [=list/empty=], then return [=a promise rejected with=] a {{TypeError}}.
    1. [=list/For each=] |request| of |requests|:
      1. Let |internalRequest| be the [=Request/request=] of the result of invoking the {{Request}} constructor with |request|.
      1. If |internalRequest|'s [=request/mode=] is "`no-cors`", then return [=a promise rejected with=] a {{TypeError}}.
      1. If |internalRequest|'s [=request/body=] is not null, then:
        1. If |internalRequest|'s [=request/body=]'s [=body/source=] is a {{ReadableStream}}, then return [=a promise rejected with=] a {{TypeError}}.
        1. Increment |uploadTotal| by |internalRequest|'s [=request/body=]'s [=body/total bytes=].

          Issue: This isn't correctly set in fetch ([issue](https://github.com/whatwg/fetch/issues/604)).
      1. Set |internalRequest|'s [=request/client=] to null.
      1. Let |record| be a new [=background fetch record=].
      1. Set |record|'s [=background fetch record/request=] to |internalReqeust|.
      1. [=list/Append=] |record| to |records|.
    1. Let |promise| be [=a new promise=].
    1. [=queue/Enqueue=] the following steps to |registration|'s [=active background fetches edit queue=]:
      1. Let |bgFetchMap| be |registration|'s [=active background fetches=].
      1. If |registration|'s [=service worker registration/active worker=] is null, then reject |promise| with a {{TypeError}} and abort these steps.
      1. If |bgFetchMap|[|id|] [=map/exists=], reject |promise| with a {{TypeError}} and abort these steps.
      1. Let |bgFetch| be a new [=/background fetch=] with:
        : [=background fetch/id=]
        :: |id|.
        : [=background fetch/records=]
        :: |records|.
        : [=background fetch/download total=]
        :: |options|' `downloadTotal` member.
        : [=background fetch/upload total=]
        :: |uploadTotal|.
        : [=background fetch/icons=]
        :: |options|' `icons` member.
        : [=background fetch/title=]
        :: |options|' `title` member.
      1. Set |bgFetchMap|[|id|] to |bgFetch|.
      1. If storing |bgFetch| fails due to exceeding a quota limit, [=reject=] |promise| with a {{QuotaExceededError}} {{DOMException}} and abort these steps.
      1. [=Resolve=] |promise| with the result of [=getting a BackgroundFetchRegistration instance=] passing the [=context object=]'s [=BackgroundFetchRegistration instances=] and |bgFetch|.
    1. Return |promise|.
  </div>

  <div algorithm>
    The <dfn method>get(|id|)</dfn> method, when invoked, must return [=a new promise=] |promise| and run the following steps [=in parallel=]:

    1. Let |registration| be the [=context object=]'s associated [=/service worker registration=].
    1. Let |bgFetch| be |registration|'s [=active background fetches=][|id|].
    1. If |bgFetch| is nothing, then [=resolve=] |promise| with undefined and abort these steps.
    1. [=Resolve=] |promise| with the result of [=getting a BackgroundFetchRegistration instance=] passing the [=context object=]'s [=BackgroundFetchRegistration instances=] and |bgFetch|.
  </div>

  <div algorithm>
    The <dfn method>getIds()</dfn> method, when invoked, must return [=a new promise=] |promise| and run the following steps [=in parallel=]:

    1. Let |registration| be the [=context object=]'s associated [=/service worker registration=].
    1. Let |ids| be the result of [=map/getting the keys=] of |registration|'s [=active background fetches=].
    1. [=Resolve=] |promise| with |ids|.
  </div>
</div>

<div algorithm>
  To <dfn data-lt="get a BackgroundFetchRegistration instance|getting a BackgroundFetchRegistration instance">get a BackgroundFetchRegistration instance</dfn> for an |instancesMap| (a [=BackgroundFetchRegistration instances=]) and a |bgFetch| (a [=/background fetch=]), run the following steps:

  1. If |instancesMap|[|bgFetch|] [=map/exists=], then return |instancesMap|[|bgFetch|].
  1. Let |instance| be a new {{BackgroundFetchRegistration}} whose [=BackgroundFetchRegistration/background fetch=] is set to |bgFetch|.
  1. Set |instancesMap|[|bgFetch|] to |instance|.
  1. Return |instance|.

  Note: This is to ensure the same instance is returned for a given [=/background fetch=] throughout the life of a {{BackgroundFetchManager}}. It's okay for browsers to optimise this, as long as there's no way to tell that more than one instance has been created for a given [=/background fetch=] (e.g through equality, expandos, or weakly-associated data).
</div>

<div algorithm>
  To <dfn>attempt a background fetch</dfn> for |bgFetch| (a [=/background fetch=]), run the following steps:

  1. Let |completeFetches| be 0.
  1. Let |abandoned| be false.
  1. Let |completeFetchesEditQueue| be the result of [=starting a parallel queue=].
  1. For each |record| in |bgFetch|'s [=background fetch/records=], run the following steps [=in parallel=]:
    1. Let |request| be a copy of |record|'s [=background fetch record/request=].
    1. Set |request|'s [=request/keepalive flag=].
    1. Set |request|'s [=request/synchronous flag=].
    1. Let |response| be the result of [=/fetching=] |request|.

      Issue: Fetch waits for the whole body before returning |response|. Let's pretend it *doesn't* do that [issue](https://github.com/whatwg/fetch/issues/536#issuecomment-330184276).

    1. If one of the following is true:
      * |response| failed due to a failed CORS check.

        Issue: Fetch doesn't currently expose this [(issue)](https://github.com/whatwg/fetch/issues/605).
      * TODO: other failure reasons?

      Then set |abandoned| to true.
    1. Otherwise, if |response| wasn't a terminal failure:
      1. Resume download somehow.

      Issue: Not yet defined.
    1. Otherwise:
      1. Let |storedResponse| be a copy of |response| except for its [=response/body=].
      1. Set |record|'s [=background fetch record/response=] to |storedResponse|.
      1. Whenever one or more bytes are transmitted from |response|'s [=response/body=]'s [=body/stream=], let |bytes| be the transmitted bytes and run these steps:
        1. Append |bytes| to |record|'s [=background fetch record/response body=].
        1. TODO: progress events
      1. If at any point the bytes transmission for |response|'s [=response/body=]'s [=body/stream=] is done normally, then [=queue/enqueue=] the following steps to |completeFetchesEditQueue|:
        1. Increment |completeFetches|.
      1. If at any point the ongoing [=/fetch=] is [=fetch/terminated=], then set |abandoned| to true.
    1. Wait for either |abandoned| to be true, or |completeFetches| to be |bgFetch|'s [=background fetch/records=]'s [=list/size=].
    1. If |abandoned| is true:
      1. TODO: terminate all related fetches.
      1. TODO: failure event.
    1. TODO: success event.
</div>

## {{BackgroundFetchRegistration}} ## {#background-fetch-registration}

<pre class="idl"><xmp>
  [Exposed=(Window,Worker)]
  interface BackgroundFetchRegistration : EventTarget {
    readonly attribute DOMString id;
    readonly attribute FrozenArray<IconDefinition> icons;
    readonly attribute unsigned long long uploadTotal;
    readonly attribute unsigned long long uploaded;
    readonly attribute unsigned long long downloadTotal;
    readonly attribute unsigned long long downloaded;
    readonly attribute DOMString title;
    readonly attribute BackgroundFetchActiveFetches activeFetches;

    Promise<boolean> abort();
  };

  [Exposed=(Window,Worker)]
  interface BackgroundFetchFetch {
    readonly attribute Request request;
  };

  [Exposed=(Window,Worker)]
  interface BackgroundFetchActiveFetches {
    Promise<BackgroundFetchActiveFetch> match(RequestInfo request);
    Promise<FrozenArray<BackgroundFetchActiveFetch>> values();
  };

  [Exposed=(Window,Worker)]
  interface BackgroundFetchActiveFetch : BackgroundFetchFetch {
    readonly attribute Promise<Response> responseReady;
    // In future this will include a fetch observer
  };
</xmp></pre>

<div dfn-for="BackgroundFetchRegistration">
  A {{BackgroundFetchRegistration}} instance has an associated <dfn>background fetch</dfn>, a [=/background fetch=].

  The <dfn attribute>id</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/background fetch=]'s [=background fetch/id=].

  The <dfn attribute>icons</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/background fetch=]'s [=background fetch/icons=].

  The <dfn attribute>uploadTotal</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/background fetch=]'s [=background fetch/upload total=].

  The <dfn attribute>uploaded</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/background fetch=]'s TODO.

  The <dfn attribute>downloadTotal</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/background fetch=]'s [=background fetch/download total=].

  The <dfn attribute>downloaded</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/background fetch=]'s TODO.

  The <dfn attribute>title</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/background fetch=]'s [=background fetch/title=].

  The <dfn attribute>activeFetches</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/background fetch=]'s TODO.

  <div algorithm>
    The <dfn method>abort()</dfn> method, when invoked, must return [=a new promise=] |promise| and run the following steps [=in parallel=]:

    1. TODO
  </div>
</div>

## Events ## {#events}

<pre class="idl"><xmp>
  partial interface ServiceWorkerGlobalScope {
    attribute EventHandler onbackgroundfetched;
    attribute EventHandler onbackgroundfetchfail;
    attribute EventHandler onbackgroundfetchabort;
    attribute EventHandler onbackgroundfetchclick;
  };
</xmp></pre>

The following is the <a>event handler</a> (and its corresponding <a>event handler event type</a>) that must be supported, as <a>event handler IDL attributes</a>, by all objects implementing {{ServiceWorker}} interface:

<table class="data">
  <thead>
    <tr>
      <th>[=event handler event type=]</th>
      <th>[=event handler=]</th>
      <th>Interface</th>
    </tr>
  </thead>
  <tbody dfn-for="ServiceWorkerGlobalScope" dfn-type="event">
    <tr>
      <td><dfn>backgroundfetched</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetched}}</td>
      <td>{{BackgroundFetchedEvent}}</td>
    </tr>
    <tr>
      <td><dfn>backgroundfetchfail</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetchfail}}</td>
      <td>{{BackgroundFetchFailEvent}}</td>
    </tr>
    <tr>
      <td><dfn>backgroundfetchabort</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetchabort}}</td>
      <td>{{BackgroundFetchEvent}}</td>
    </tr>
    <tr>
      <td><dfn>backgroundfetchclick</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetchclick}}</td>
      <td>{{BackgroundFetchClickEvent}}</td>
    </tr>
  </tbody>
</table>

### {{BackgroundFetchEvent}} ### {#background-fetch-event}

<pre class="idl"><xmp>
  [Constructor(DOMString type, BackgroundFetchEventInit init), Exposed=ServiceWorker]
  interface BackgroundFetchEvent : ExtendableEvent {
    readonly attribute DOMString id;
  };

  dictionary BackgroundFetchEventInit : ExtendableEventInit {
    required DOMString id;
  };
</xmp></pre>

<div dfn-for="BackgroundFetchEvent">
  A {{BackgroundFetchEvent}} has an associated <dfn>id</dfn>, a DOMString.

  The <dfn attribute>id</dfn> attribute must return the [=BackgroundFetchEvent/id=].

  TODO
</div>

<div algorithm>
  The <dfn constructor for="BackgroundFetchEvent">BackgroundFetchEvent(|type|, |init|)</dfn> constructor, when invoked, must run these steps:

  1. TODO
</div>

### {{BackgroundFetchedEvent}} ### {#background-fetch-end-event}

<pre class="idl"><xmp>
  [Constructor(DOMString type, BackgroundFetchedEventInit init), Exposed=ServiceWorker]
  interface BackgroundFetchedEvent : BackgroundFetchEvent {
    readonly attribute BackgroundFetchSettledFetches fetches;

    Promise<void> updateUI(DOMString title);
  };

  dictionary BackgroundFetchedEventInit : BackgroundFetchEventInit {
    required BackgroundFetchSettledFetches fetches;
  };

  [Exposed=(Window,Worker)]
  interface BackgroundFetchSettledFetches {
    Promise<BackgroundFetchSettledFetch> match(RequestInfo request);
    Promise<FrozenArray<BackgroundFetchSettledFetch>> values();
  };

  [Exposed=ServiceWorker]
  interface BackgroundFetchSettledFetch : BackgroundFetchFetch {
    readonly attribute Response? response;
  };
</xmp></pre>

<div dfn-for="BackgroundFetchedEvent">
  The <dfn attribute>completeFetches</dfn> attribute must return TODO.

  <div algorithm>
    The <dfn method>updateUI(|title|)</dfn> method, when invoked, must return [=a new promise=] |promise| and run the following steps [=in parallel=]:

    1. TODO
  </div>
</div>

<div algorithm>
  The <dfn constructor for="BackgroundFetchedEvent">BackgroundFetchedEvent(|type|, |init|)</dfn> constructor, when invoked, must run these steps:

  1. TODO
</div>

### {{BackgroundFetchFailEvent}} ### {#background-fetch-fail-event}

<pre class="idl"><xmp>
  [Constructor(DOMString type, BackgroundFetchedEventInit init), Exposed=ServiceWorker]
  interface BackgroundFetchFailEvent : BackgroundFetchedEvent {
    readonly attribute BackgroundFetchSettledFetches fetches;
  };

  dictionary BackgroundFetchFailEventInit : BackgroundFetchedEventInit {
    required BackgroundFetchSettledFetches fetches;
  };
</xmp></pre>

### {{BackgroundFetchClickEvent}} ### {#background-fetch-click-event}

<pre class="idl"><xmp>
  [Constructor(DOMString type, BackgroundFetchedEventInit init), Exposed=ServiceWorker]
  interface BackgroundFetchClickEvent : BackgroundFetchEvent {
    readonly attribute BackgroundFetchState state;
  };

  dictionary BackgroundFetchClickEventInit : BackgroundFetchEventInit {
    required BackgroundFetchState state;
  };

  enum BackgroundFetchState { "pending", "succeeded", "failed" };
</xmp></pre>

# Privacy and bandwidth usage # {#privacy-and-bandwidth-use}

It's the recommendation of this standard that user agents make background fetch operations highly visible and easily abortable rather than asking permission up front. However, given that background fetches can be paused and retried, a user agent that immediately paused a background fetch and user interaction to resume would be compliant.

The [=/origin=] of a background fetch should have equal or great visibility to the developer-provided information, such as a the [=background fetch/icons=] and [=background fetch/title=].

A user agent may pause background downloads depending on network conditions or battery state. For example, a user agent may download automatically when connected to WiFi, but require user confirmation to download using mobile data. If an implementation has this restriction, the user should be able to persist granting mobile data use for the [=/origin=].

A background fetch exposes the user's external IPs to the server throughout the duration of the background fetch. An attacker could use an extremely slow background fetch as a way to persistently track the user once they've left the site. Good visibility into the progress of the background fetch will help the user identify unwanted use.
